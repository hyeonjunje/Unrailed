using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using UnityEngine.UI;

public class BTNodeBase : BTElementBase
{
    protected List<BTNodeBase> _children = new List<BTNodeBase>();
    protected List<BTDecoratorBase> _decorators = new List<BTDecoratorBase>();
    protected List<BTServiceBase> _services = new List<BTServiceBase>();

    //진입
    protected System.Func<BehaviorTree.ENodeStatus> onEnterFn;

    //업데이트
    protected System.Func<BehaviorTree.ENodeStatus> onTickFn;


    public BehaviorTree.ENodeStatus LastStatus { get; protected set; } = BehaviorTree.ENodeStatus.Unknown;
    public bool DecoratorsPermitRunning { get; protected set; } = true;

    //생성자
    public BTNodeBase(string _Name = "", System.Func<BehaviorTree.ENodeStatus> _OnEnterFn = null,
    System.Func<BehaviorTree.ENodeStatus> _OnTickFn = null)
    {
        Name = _Name;
        onEnterFn = _OnEnterFn;
        onTickFn = _OnTickFn;
    }



    //Node 추가하기
    public BTNodeBase Add<T>(string _Name,
        System.Func<BehaviorTree.ENodeStatus> _OnEnterFn = null,
        System.Func<BehaviorTree.ENodeStatus> _OnTickFn = null) where T : BTNodeBase, new()
    {
        T newNode = new T();
        newNode.Name = _Name;
        newNode.onEnterFn = _OnEnterFn;
        newNode.onTickFn = _OnTickFn;

        return Add(newNode);
    }

    public BTNodeBase Add<T>(T newNode) where T : BTNodeBase
    {
        _children.Add(newNode);
        return newNode;
    }


    public BTNodeBase AddService<T>(string _Name, System.Action<float> _OnTickFn) where T : BTServiceBase, new()
    {
        T newService = new T();
        newService.Init(_Name, _OnTickFn);

        _services.Add(newService);

        return this;
    }

    public BTNodeBase AddService<T>(T newService) where T : BTServiceBase
    {
        _services.Add(newService);

        return this;
    }

    public BTNodeBase AddDecorator<T>(string _Name, System.Func<bool> _OnEvaluateFn) where T : BTDecoratorBase, new()
    {
        T newDecorator = new T();
        newDecorator.Init(_Name, _OnEvaluateFn);

        _decorators.Add(newDecorator);

        return this;
    }

    public BTNodeBase AddDecorator<T>(T newDecorator) where T : BTDecoratorBase
    {
        _decorators.Add(newDecorator);

        return this;
    }

    private void TickServices(float deltaTime)
    {
        foreach (var service in _services)
            service.OnTick(deltaTime);
    }
    private bool EvaluateDecorators()
    {
        bool canRun = true;

        foreach (var decorator in _decorators)
        {
            canRun = decorator.Evaluate();
            //Evaluate는 BTSetup의 데코레이터 부분의 결과를
            //AND 연산한 결과

            //하나라도 false일시 중단
            if (!canRun)
                break;
        }

        if (canRun != DecoratorsPermitRunning)
        {
            DecoratorsPermitRunning = canRun;

            //데코레이터의 실행 가능 여부가 변경되었다면 초기화
            if (canRun)
                Reset();
        }

        return canRun;
    }
    protected virtual void OnAbort()
    {
        Reset();
    }

    public virtual void Reset()
    {
        LastStatus = BehaviorTree.ENodeStatus.Unknown;

        foreach (var child in _children)
            child.Reset();
    }

    public void Tick(float deltaTime)
    {
        bool tickedAnyNodes = OnTick(deltaTime);

        //더 이상 없으면 처음으로 돌리기
        if (!tickedAnyNodes)
            Reset();
    }

    protected virtual void OnEnter()
    {
        //진입하기
        //뭔가 하나라도 Add 했으면 null이 아님
        if (onEnterFn != null)
            LastStatus = onEnterFn.Invoke();
        else
            LastStatus = _children.Count > 0 ? BehaviorTree.ENodeStatus.InProgress : BehaviorTree.ENodeStatus.Succeeded;
    }

    protected virtual bool OnTick(float deltaTime)
    {
        //반환값이 false라면 노드 종료
        //반환값이 true라면 계속 진행


        bool tickedAnyNodes = false;

        //데코레이터 조건을 만족하는지 검사
        //DecoratorsPermitRunning의 기본값은 true
        //이게 false라면
        if (!DecoratorsPermitRunning)
        {
            //실패로 설정하고 이 노드를 실행했다고 표시
            LastStatus = BehaviorTree.ENodeStatus.Failed;
            tickedAnyNodes = true;
            return tickedAnyNodes;
        }

        //서비스 업데이트하기
        TickServices(deltaTime);


        //처음 진입시
        if (LastStatus == BehaviorTree.ENodeStatus.Unknown) //기본값
        {
            //진입
            OnEnter();
            tickedAnyNodes = true;

            if (LastStatus == BehaviorTree.ENodeStatus.Failed)
                return tickedAnyNodes;
        }

        // 진행 단계
        if (onTickFn != null)
        {
            //onTick 함수를 실행하여 반환된 상태로 업데이트
            LastStatus = onTickFn.Invoke(); 
            tickedAnyNodes = true;

            //반환한게 진행중이 아닌 성공/실패 상태일 때는 Tick된 모든 노드를 반환하고
            // 
            if (LastStatus != BehaviorTree.ENodeStatus.InProgress)
                return tickedAnyNodes;
        }

        // 자녀 노드가 없을 때
        if (_children.Count == 0)
        {
            if (onTickFn == null)
                LastStatus = BehaviorTree.ENodeStatus.Succeeded; //성공 상태로 업데이트

            return tickedAnyNodes; // 종료 
        }

        //실행
        for (int childIndex = 0; childIndex < _children.Count; ++childIndex)
        {

            //자식 노드 가져오기
            var child = _children[childIndex];

            //이전 데코레이터에서 성공 여부
            bool childPreviouslyEnabledByDecorators = child.DecoratorsPermitRunning;


            //canRun 반환값
            bool childCurrentlyEnabledByDecorators = child.EvaluateDecorators();

            //만약에 위에서 childPreviouslyEnabledByDecorators가
            //1. false일 경우
            //그러면 여기서 EvaluateDecorators를 할 때 canRun은 true고
            //DecoratorsPermitRunning은 false인 상황이 발생해서 여기서 자식들을 다 초기화한 후
            //true

            //2. true일 경우
            //자식들 초기화 안하고 true


            //자식 노드가 "InProgress" 상태일 때 
            if (child.LastStatus == BehaviorTree.ENodeStatus.InProgress)
            {
                //자식 노드가 실행시키기
                tickedAnyNodes |= child.OnTick(deltaTime);
                //성공, 실패 여부 반환
                return tickedAnyNodes;
            }

            //자식 노드가 진행중이라면 다음 노드로 넘어가기
            if (child.LastStatus != BehaviorTree.ENodeStatus.Unknown)
                continue;

            //자식 노드 실행시키기
            tickedAnyNodes |= child.OnTick(deltaTime);


            LastStatus = child.LastStatus;
            //다 초기화 때린 상황
            if (!childPreviouslyEnabledByDecorators && childCurrentlyEnabledByDecorators)
            {
                //다음 자식들도 다 초기화
                for (int futureIndex = childIndex + 1; futureIndex < _children.Count; ++futureIndex)
                {
                    var futureChild = _children[futureIndex];
                    if (futureChild.LastStatus == BehaviorTree.ENodeStatus.InProgress)
                        futureChild.OnAbort();
                    else
                        //성공/실패시 자식들 상태를 Unknown으로 바꿔주기
                        futureChild.Reset();
                }
            }


            if (child.LastStatus == BehaviorTree.ENodeStatus.InProgress)
                return tickedAnyNodes;

            //추가적인 평가가 필요 없는 상황
            //Sequence의 경우, 실패 시 처음으로 돌아가기
            else if (child.LastStatus == BehaviorTree.ENodeStatus.Failed &&
                !ContinueEvaluatingIfChildFailed())
            {
                return tickedAnyNodes;
            }
            //Selector의 경우, 성공 시 처음으로 돌아가기
            else if (child.LastStatus == BehaviorTree.ENodeStatus.Succeeded &&
                !ContinueEvaluatingIfChildSucceeded())
            {
                return tickedAnyNodes;
            }
        }
        //상태 업데이트
        OnTickedAllChildren();

        return tickedAnyNodes;
    }

    protected virtual bool ContinueEvaluatingIfChildFailed()
    {
        return true;
    }

    protected virtual bool ContinueEvaluatingIfChildSucceeded()
    {
        return true;
    }

    protected virtual void OnTickedAllChildren()
    {

    }

    public string GetDebugText()
    {

        StringBuilder debugTextBuilder = new StringBuilder();
        GetDebugTextInternal(debugTextBuilder);
        return debugTextBuilder.ToString();
    }

    protected override void GetDebugTextInternal(StringBuilder debugTextBuilder, int indentLevel = 0)
    {
        for (int index = 0; index < indentLevel; ++index)
            debugTextBuilder.Append(' ');

        debugTextBuilder.Append($"{Name} [{LastStatus.ToString()}]");

        foreach (var service in _services)
        {
            debugTextBuilder.AppendLine();
            debugTextBuilder.Append(service.GetDebugText(indentLevel + 1));
        }

        foreach (var decorator in _decorators)
        {
            debugTextBuilder.AppendLine();
            debugTextBuilder.Append(decorator.GetDebugText(indentLevel + 1));
        }

        foreach (var child in _children)
        {
            debugTextBuilder.AppendLine();
            child.GetDebugTextInternal(debugTextBuilder, indentLevel + 2);
        }
    }

}
